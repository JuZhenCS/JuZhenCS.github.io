{"categories":[{"title":"生物信息","uri":"https://juzhencs.github.io/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"}],"posts":[{"content":"","id":0,"section":"posts","summary":"","tags":null,"title":"Posts","uri":"https://juzhencs.github.io/posts/","year":"2019"},{"content":"我要吹爆VSCode！！！ 本篇博文可能没什么实际意义，只是白表达一下我个人对VSCode的热爱之情\n我要吹爆VSCode！！！\n我要吹爆VSCode！！！\n我要吹爆VSCode！！！\n我用过很多桌面发行版，但是都解决不了稳定的问题，所以笔记本最终还是回到了微软爸爸的怀抱。 不过服务器一直是Linux的，而且工作也都是在服务器上完成，笔记本的主要角色就是编辑器。 各种编辑器用遍后，现在感觉VSCode最好用。那种你不知道它好在哪里，但是没了它就是不行的那种好用。\n半年前更是推出了ssh远程连接服务器的功能，只要ssh到服务器上，就能像在本地一样编辑文件。 请注意这里的像在本地一样，是真的和本地一模一样，有代码提示，会自动查找(Linux上的)库，而且完全没有延迟。\n另外自带的ssh插件不论配色还是字体也都很合适，配置文件与密钥也和linux系统一样。putty之类的已经完全没啥用了。\n总之\n我要吹爆VSCode！！！\n我要吹爆VSCode！！！\n我要吹爆VSCode！！！\n","id":1,"section":"posts","summary":"我要吹爆VSCode！！！ 本篇博文可能没什么实际意义，只是白表达一下我个人对VSCode的热爱之情 我要吹爆VSCode！！！ 我要吹爆VSCo","tags":["VSCode","工具推荐"],"title":"我要吹爆VSCode！！！","uri":"https://juzhencs.github.io/2019/12/2019-12-27/","year":"2019"},{"content":"最长公共子序列O(lgmn)算法 问题描述：\n 给定两个序列\n序列1： C T G A C\n序列2： G T A G\n求两个序列的最长公共子序列\n显然，T G就是一个最长公共子序列\n另外，G A和T A也是，最长公共子序列通常不唯一\n最长公共子序列(Longest Common Subsequence)为了方便简写成LCS\n 继续上面的问题，给序列2延长一位X(如下所示)：\n 序列1： C T G A C\n序列2： G T A G X\n序列1去掉末尾C与序列2的最长公共子序列为LCS_left\n序列1与序列2去掉末尾X的最长公共子序列为LCS_up\n序列1去掉末尾C与序列2去掉末尾X的最长公共子序列为LCS\u0026rsquo;\n要求的是序列1与序列2的最长公共子序列LCS\n 那么有以下两种种情况：\n X和序列1末尾的C相等(X是C)，那么LCS'延长一位C就是LCS。 X和序列1末尾的C不等(X非C)，那么LCS_left和LCS_up里最长的那个就是LCS。  第一种情况很好理解，就相当于有两个序列，末尾都添加了一样的字符，那么之前的LCS\u0026rsquo;(T G)延长一位就是现在的LCS(T G C)。\n第二种情况可以分开讨论。一种情况是LCS比LCS'更长，那显然是延长了一位，这一位或者是序列1末尾的C( LCS = LCS_up \u0026gt; LCS_left )，或者是序列2末尾的X( LC S= LCS_left \u0026gt; LCS_up )。另一种情况是LCS相比LCS'没有更长，那么LCS\u0026rsquo;，LCS_up和LCS_left就是相等的(LCS=LCS_up=LCS_left)。可见这两种情况下，让LCS等于LCS_left和LCS_up中大的那个都没问题。\n要求LCS显然需要知道LCS\u0026rsquo;，LCS_up和LCS_left，没错，这就是典型的动态规划算法。创建一个矩阵，用来保存中间结果。\n    C T G A C     G 0 0 1      如同上面的表格所示，横向是序列1，纵向是序列2(只计算都到第一个元素)，表格的值代表比对到这里时，LCS的长度。\n表格值上面的值就是LCS_up的长度，同理，左边的值就是LCS_left的长度，左上是LCS'的长度。\n现在比对到序列1的G和序列2的G，元素相同，所以当前的值应该是左上LCS'长度的值加一。左上不存在，代表没有LCS\u0026rsquo;，所以长度是0，0加1等于1。\n    C T G A C     G 0 0 1 1     如上表所示，比对到了序列1的A和序列2的G，元素不同，所以左边和上边哪个值大，选大的值填入。上方没有值，所以默认是0，左边是1，左边大，填入左边的值。\n这个表格就是得分矩阵D，两个字符串记为X和Y，长度分别是m和n，X(i)代表字符串X的第i个元素，Y(j)同理，D(i, j)代表得分矩阵对应X(i)Y(j)时的值。填表的过程就是计算得分矩阵的过程，根据得分矩阵，就可以找到最长公共子序列。\n以上的填表规则可以总结为：\n$$D(i, j) = D(i-1, j-1) \\quad if X(i) = Y(j)$$\n$$D(i, j) = Max(D(i-1, j), D(i, j-1)) \\quad if X(i) != Y(j)$$\n根据以上公式计算出的完整得分矩阵如下(X = A)：\n    C T G A C     G 0 0 1 1 1   T 0 1 1 1 1   A 0 1 1 2 2   G 0 2 2 2 2   A 0 1 2 3 3    把矩阵当中相同的数组看作同一个颜色的色块，每个色块的左上方尖角所对应的元素，就是LCS的组成元素。从矩阵的右下方向左上方回溯，从一个尖角找到离他最近的左上方的尖角，直到矩阵左上方。这祖组尖角就是倒序的LCS。\n如上所示的矩阵，LCS是T G A。\n动态规划的方法求解LCS，就是计算得分矩阵的过程，显然时间复杂度和空间复杂度都是O(lgmn)。而这实际也是目前通用的最好的复杂度，不过再面对一些具体问题的时候也可以做一些优化。\n最长递增子序列(LIS)算法 先介绍一个前置问题，最长递增子序列问题。\n 一个不重复的数字序列(01, 06, 17, 07, 09, 14, 08, 18, 02, 05)，求这个序列最长的增长子序列。\n最长递增子序列(Longest Increase Subsequence)简称LIS。\n上面序列的LIS是(01, 06, 07, 09, 14, 18)\n 求解LIS的方法，思想上依然朴实，就是一个一个元素的延长序列，也就是动态规划。\n假设序列从1开始，延长到了17，即(01, 06, 17)，显然序列的LIS就是(01, 06, 17)。简单的记录下这个LIS如下。\n          01 06 17    这时延长一个元素X，如果X比17大，那么新的LIS就是(01, 06, 17, X)，如果X比17小呢？\n这个实例当中X是7，考虑之前的序列当中，1和6仍是比7小，所以有了两个等长的LIS，(01, 06, 17)和(01, 06, 07)在上面的表格当中把07写在17的下方。07和17同在第三列表示他们都是各自LIS的第三位，07在17下方，表示07在原序列中的位置比17靠后。\n          01 06 17    07     类似的，继续填表。\n            01 06 17      07 09 14     接下来是08，08比07大，所以在第四列，比09晚，所以在09下面，再加一行。\n            01 06 17      07 09 14      08      接下来是18，18比之前最大的14更大，所以排在第六列，又不比08更晚，如果和14同行表示比08早，显然不行，所以要和08同行。\n             01 06 17       07 09 14       08  18     剩下的元素依照上述规则继续填入表格，最终结果如下。\n             01 06 17       07 09 14       08  18    02 05        从表格的最右列的最下行开始，向左上回溯，只要在当前元素左边和上边的元素都是比当前元素小，且在当前元素之前出现的。从右下到左上，找到一条经过最多列的路径，就是LIS。上面的实例可以得到两条LIS(01, 06, 17或07, 09, 14, 18)。\n以上算法需要遍历n(序列长度)个元素，遍历每个元素都需要查找一次元素的位置(时间复杂度O(lgn))，所以时间复杂度是O(nlgn)，如果用十字链表存储元素，空间复杂度是O(n)。\n实际上如果只是求LIS的长度，而不需要得到具体的LIS，那么以上矩阵可以压缩成一个数组(一列压缩成一个元素)，每列都只保留最下面的元素就可以了，这也是大多数求LIS长度算法的实现，类似下面这样。\n             01 02 05 08 14 18    最长公共子序列O(nlgn)算法 我们知道LIS的时间复杂度是O(nlgn)，那么如果能把LCS问题转化为LIS问题，时间LCS的复杂度就是O(nlgn)了。\n转化的方法是把序列1中的元素用这个元素在序列2中的位置替换，举个栗子。\n 序列1： C T G A C\n序列2： G T A G\n序列1的第一个元素C，不在序列2中，所以忽略。第二个元素T在序列2中的位置是(2),替换。\n序列1： null (2) G A C\n序列2： G T A G\n依此类推\n序列1： null (2) (1, 4) (3) null\n序列2： G T A G\n 显然，现在只要求出序列1的LIS，就得到了LCS，但是其中一个限制是每个括号内只能选出一个元素，这样很不方便计算。\n一个小技巧是把括号内的数字按从大到小排序，这样就可以保证每个括号内最多只能选出一个元素，也就可以把括号去掉了，最终的替换结果如下。\n 序列1： 2 4 1 3\n序列2： G T A G\n 求得序列1的LIS结果对应到序列2的顺序就得到了LCS，结果如下。\n 2 4(T G), 2 3(T A), 1 3(G A)\n 以上的例子当中，每个序列都只有四种元素(A C G T)，这四种元素的集合就是字母表(alphabet)。上面的算法适合字母表比较大的序列。\n举个极端的例子。\n 序列1： A A A A\n序列2： A A A A A\n 这时序列1的替换就成了长度为nm的序列。\n 序列1： (5 4 3 2 1) (5 4 3 2 1) (5 4 3 2 1) (5 4 3 2 1)\n 那么求解的时间复杂度就退化为O(mnlgmn)，大于动态规划的O(mn)。\n实际动态规划算法还有更多的灵活应用，因此在生物信息的序列比对领域，依然是最常用最基础的算法。\n","id":2,"section":"posts","summary":"最长公共子序列O(lgmn)算法 问题描述： 给定两个序列 序列1： C T G A C 序列2： G T A G 求两个序列的最长公共子序列 显然，T G就是一个最长公共","tags":["动态规划","最长公共子序列","最长递增子序列"],"title":"最长公共子序列算法","uri":"https://juzhencs.github.io/2019/11/2019-11-18/","year":"2019"},{"content":"vEB tree算法简介 vEB tree是VAN EMDE BOAS Tress的缩写，是一种 时间复杂度为O(lglgU) 的查找算法。基于比较操作的查找算法最佳时间复杂度为O(lgn)，vEB tree算法借用了一些 位操作 的技巧，将时间复杂度降低为O(lglgn)，所以在问题规模相对问题空间较大的情况下有较好的表现。它是由一个荷兰计算机学家Peter van Emde Boas领导的团队在1975年发明的。参考文献如下，如果链接过期了的话也可以根据论文名字重新搜索。\nvan Emde Boas, Peter. \u0026ldquo;Preserving order in a forest in less than logarithmic time.\u0026rdquo; 16th Annual Symposium on Foundations of Computer Science (sfcs 1975). IEEE, 1975.\n另外作者在1977年改进了算法，将空间复杂度降低为线性，参考文献如下。\nvan Emde Boas, Peter. \u0026ldquo;Preserving order in a forest in less than logarithmic time and linear space.\u0026rdquo; Information processing letters 6.3 (1977): 80-82.\n引子:传统的二分查找  问题:\n给定一个递增的序列x[n]，用二分查找数值a是否存在序列当中。\n解答：\n 取序列二分点的数值和a对比，如果二分点的数值等于a，或序列长度为1则结束。 如果二分点大于a，则去掉序列后半段，否则去点序列前半段，返回1步。   以上就是典型的二分查找，每次都把序列对半分，直到序列长度为1，最坏的情况下可能操作x次。即:\n$$n(\\frac{1}{2})^x=1$$\n显然:\n$$x=log_2^n$$\n接下来思考一个问题， 如果每次不是二分，而是多分 是不是可以算的更快呢？\nvEB tree算法 数据存储在计算机当中是二进制的，计算机对数据的运算最终都是执行一些位操作。如果考虑位操作的话，其实每次是可以将数据$\\sqrt n$分的。考虑数字16，可以分解为4x4，4是$2^2$二进制是0B 100，16是$2^4$二进制表示是0B 10000，刚好是0B 100乘方的结果。\n假设有为0-15，共16个数，那么把这16个数全部用二进制表示如下：\n             十进制 0 1 2 3   二进制 00 00 00 01 00 10 00 11   十进制 4 5 6 7   二进制 01 00 01 01 01 10 01 11   十进制 8 9 10 11   二进制 10 00 10 01 10 10 10 11   十进制 12 13 14 15   二进制 11 00 11 01 11 10 11 11     可以看到如果把二进制表示的数前后各两个比特位拆开，前两个比特位相同的数字合为一段，可以把大小为16的空间拆分成$\\sqrt16$即4段。后两个比特位则可以表示数字在段当中的位置。比如数字9，拆分后，属于0B 10段，在段中的0B 01位。\n另外再说明一下问题空间U和问题规模n，如上述例子，所有的数都在0-15范围内，问题空间U就是16。假设查找其中的2、4、11，三个数，问题规模n就是3。\n现在vEB tree的核心思想就可以理解了，将要查找的数据按照二进制对半分(高位补零)，前半部分为段值，后半部分为段内的位置。再段内位置作为问题空间递归的查找下去，直到找到或者问题空间大小为2为止。\n举个例子，问题空间为256，查找数字7。二进制7为0B 0000 0111(高位补零)，首次查找在0B 0000段，段内0B 0111位置。将段内位置作为问题空间递归查找，二次查找在0B 01段，段内0B 11位置。三次查找，在0B 1段，段内0B 1位置。查找结束。\n以上就是最朴素的vEB tree思想的查找方法，每次都把问题空间开方分，直到问题空间为2，最坏的情况下可能操作x次。即:\n$$U^{\\frac{1}{2^x}}=2$$\n显然:\n$$x=log_2^{log_2^U}$$\nvEB tree的数据结构 vEB tree是递归定义的，所以实际上vEB tree的数据结构很简单，只需要理解一个节点就可以了。\n一个节点就是一个$\\sqrt U$叉树，每个分支就是一个段，分支的值是一个指针，指向下一级节点。\n每个节点包含两个特殊变量，最大值和最小值，表示这个节点以及它之下子节点存储的值当中的最大和最小值，如果是负数，则表示这个节点是空节点。\n 节点{\n最大值\n最小值\n子节点1\n\u0026hellip;\n子节点n\n}\n 以上就是vEB tree的基本思想，更详细的介绍可以参考机械工业出版社的《算法导论》。\nvEB tree的基本操作时间复杂度都是O(lglgU)，所以对于在问题空间当中分布密集的数据有很好的表现。不过由于关键字限制在0-U之间，所以实际应用范围有限。\n另外现在看起来vEB tree的空间复杂度是O(U)，实际上通过哈希，可以降低到O(n)。\n","id":3,"section":"posts","summary":"vEB tree算法简介 vEB tree是VAN EMDE BOAS Tress的缩写，是一种 时间复杂度为O(lglgU) 的查找算法。基于比较操作的查找算法最佳时间复杂度","tags":null,"title":"vEB tree算法简介","uri":"https://juzhencs.github.io/2019/10/2019-10-26/","year":"2019"},{"content":"ntp不同步问题(Windows做时钟源) 配置linux的ntp同步遇到问题(ubuntu16.04+ntp):\n本地机器的ntpd进程在运行，但是不与服务器同步时间，试过各种方法都不能解决。\n用ntpq -p命令能够显示与服务器的时间差，但是不修改本地时间，且服务器前没有星号。\n问题出在时钟源上，windows搭建的时钟源偏差过大，而linux默认只接受偏差1.5秒内的时钟源，应该换linux的时钟源。\n比较绥靖的解决办法是在本地机器配置文件/etc/ntp.conf开头添加一行。\n接受最大偏差不超过15秒的时钟源(可能导致时钟不精确)：\ntos maxdist 15 ","id":4,"section":"posts","summary":"ntp不同步问题(Windows做时钟源) 配置linux的ntp同步遇到问题(ubuntu16.04+ntp): 本地机器的ntpd进程在运行","tags":null,"title":"ntp不同步问题(windows做时钟源)","uri":"https://juzhencs.github.io/2019/04/2019-04-04/","year":"2019"},{"content":"最长回文子串(Manacher)算法朴实理解 今天找求解最长回文子串的算法，发现居然有O(n)复杂度的解法。必须找博客拜读一下。\n然而大神们的博客都写得太学术了，欺负我智商低。像大唐白居易一样，写的诗老妪能解多好。(典故出自一些笔记小说，实际信不得的)\n作为一个笨人，整理一个自己的朴实理解的版本，希望对大家有帮助。\n预处理 假设有串S = \u0026ldquo;12321\u0026rdquo;，求他的最长回文子串。\n首先在串的中间(包括首尾)加特殊字符，只要是串里本来没有的字符就行。于是\nS = \u0026ldquo;#1#2#3#2#1#\u0026rdquo;\n子串长度数组P 建立一个数组P，P和串S长度一样。P[i]的值就是以S[i]为中心的最长子串的半径。\n举个栗子：\nS = \u0026ldquo;# 1 # 2 # 3 # 2 # 1 #\u0026rdquo;\nP = [0 1 0 1 0 5 0 1 0 1 0]\n显然，最大的P[i]对应的S[i]的最大回文子串，就是要求的S的最大回文子串。\n求解数组P 首先非常朴实的求解，也就是遍历S[i]的左右，看是否相等，得到以下结果。\n S = \u0026ldquo;# 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 #\u0026rdquo;\nP = [0 1 0 1 0 1 0 1 0 9 \u0026hellip;]\n 算到这就可以偷懒了。\n我们已经知道了以5为中心，左右9的范围，是一个回文子串，我们叫这个范围为已知范围。\n考虑一下5右边的#，我们叫它\u0026quot;小右\u0026rdquo;，它在已知范围，最长回文子串长度未知。\n考虑一下5左边的#，我们叫它\u0026quot;小左\u0026rdquo;，它在已知范围，最长回文子串长度已知。\n\u0026ldquo;小右\u0026quot;和\u0026quot;小左\u0026quot;是对称的，它们的最长回文子串长度自然也是相同的。\n所以 \u0026ldquo;小右\u0026quot;的最长回文子串长度不用算。 照抄\u0026quot;小左\u0026quot;的就行。\n继续偷懒，得到以下结果。\n S = \u0026ldquo;# 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 #\u0026rdquo;\nP = [0 1 0 1 0 1 0 1 0 9 0 1 0 1 0 1 0 \u0026hellip;]\n 偷懒这里要停一下了，即将计算1的最长回文子串长度。\n如果继续偷懒，1还在已知范围，但1的最长回文子串边界和已知范围的边界有重合了。\n在这种情况下就要朴实的计算1的最长回文子串。\n S = \u0026ldquo;# 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 #\u0026rdquo;\nP = [0 1 0 1 0 1 0 1 0 9 0 1 0 1 0 1 0 16 \u0026hellip;]\n 现在已知范围更新为以1为中心的，左右16的范围了。然后又可以愉快的偷懒了。\n重复这种朴实计算，然后偷懒，不能偷懒就朴实计算，然后再偷懒的过程，得到最终结果。\n S = \u0026ldquo;# 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 # 2 # 3 # 4 # 5 # 4 # 3 # 2 # 1 #\u0026rdquo;\nP = [0 1 0 1 0 1 0 1 0 9 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 9 0 1 0 1 0 1 0 1 0]\n 总结算法 Manacher算法的核心就是计算子串长度数组P。亮点是利用已知信息在计算过程中偷懒。\n朴实的理解过程如下：\n 从0开始计算P[i]，并设定已知范围。 如果以P[i]为中心，P[i]在已知范围内的对应点的最长子串半径为半径。  ","id":5,"section":"posts","summary":"最长回文子串(Manacher)算法朴实理解 今天找求解最长回文子串的算法，发现居然有O(n)复杂度的解法。必须找博客拜读一下。 然而大神们的博","tags":null,"title":"最长回文子串(Manacher)算法的朴实理解","uri":"https://juzhencs.github.io/2018/07/2018-07-31/","year":"2018"},{"content":"软件开发的一些建议 最近在机缘巧合下看到了几个关于软件开发的观点. 虽然都是别人的观点,但是我很认同,记录下来,方便以后查看.\n新人代码的极限 新人开发一个项目,那么这个项目大小的极限大概在1500行代码左右.\n这是因为在1500行代码之前,不需要什么设计模式,模块化编程,面向对象等等. 不论代码有多烂,1500行内的代码复杂度总不会太高.硬凭记忆和智商能理解的了.\n突破了1500极限需要模块化,面向对象等等方法.下一个极限会在2w行左右到来. 突破2w行极限,需要面向接口编程,设计模式等方法. 再下一个极限在20w左右,不过我不知道是不是真的. 总之写大项目的核心就是:\u0026ldquo;让代码的复杂度,随行数线性而不是指数增加.\u0026quot;\n写出可维护代码的理论 很多科班出身的人,算法很好,然而代码很烂,比如我. 写出可维护的代码基本论文有三个:\n 坚持简单原则 可维护需要在项目一开始就考虑 只遵循一套原则(规范)  理论很简单,结合实际理解一下的话,就是:\n代码单元越小越好,不超过15行最好.方便复用.\n代码单元越简单越好,最好分支不超过4个.方便修改测试.\n不写重复代码,即6行或以上相同的代码.方便源码定位.\n保持接口简单,参数不要超过4个.简单上下文易重用和理解.\n分离模块间的关注点,类不要太大.体积小耦合就小.\n用消息共享内存,消息传共享内存的指针.避免锁.\n开发和测试尽量自动化.省钱省时间.\n坚持不信任原则 从输入到输出,处处设防,可以提高代码的健壮性.\n输入是不是空,长度是否符合,内容是否安全等\n服务本身不可信,要监控请求量,成功量,失败量,关键节点可用等.\n依赖系统不可信,关键路径要备份.派票系统数据库要备份.\n请求不可信,要做ip鉴权,白名单,限制最大请求量等.\n机器不可信,宕机时刻会发生,要有容灾和心跳检测.\n网络不可信,这个大家都知道.\n人不可信,防止人乱操作.要做好日志,备份,回滚.\n","id":6,"section":"posts","summary":"软件开发的一些建议 最近在机缘巧合下看到了几个关于软件开发的观点. 虽然都是别人的观点,但是我很认同,记录下来,方便以后查看. 新人代码的极限 新人","tags":null,"title":"软件开发的一些建议","uri":"https://juzhencs.github.io/2018/07/2018-07-04/","year":"2018"},{"content":"Deamon Sync使用教程-同步相片和文件到本地 Daemon Sync介绍 Daemon Sync能够将手机中的相片或者其他应用同步到本地服务器上.它跨平台的,服务端可以安装在linux macos windows上,客户端可以安装在安卓和iso上. Daemon Sync由Daemon Tools团队开发,不过并不收费.据他们官网上的介绍是这是一款情怀软件,所以大家可以免费使用. 个人觉得不排除未来新版本收费的可能,不过现在的版本许可证是无限期的,而且也很好用,未来收费的话就不升级呗.\n百度一下就能找到官网下载了,就不放连接了. 因为是情怀软件,所以不像商业软件那样有漂亮的文档. 我用的是linux,而官网并没有linux安装教程,折腾出来之后做个linux下的安装记录,方便和我一样的兄dei们少走弯路吧. (不过windows和mac应该是有的吧.)\n本文没有windows和mac服务端的安装介绍,不过你可以参考linux的安装方式.\nDaemon Sync在linux下服务端安装过程 我的安装环境是ubuntu16.04的docker镜像,虽然我是把它跑在docker里的,但是和用原生用ubuntu应该也是一样的.\nDaemon Sync不支持ipv6.(ipv6基本都是公网嘛,不安全)\nDaemon Sync当前版本客户端只能上传,不能删除服务端的数据.\n 在官网下载linux安装包 安装这个包  sudo dpkg -i daemonsync*.deb //dpkg -i安装软件  运行deamonsync  /etc/init.d/daemonsync start //start运行stop停止status查看状态\r 浏览器打开127.0.0.1:8084,进入配置界面,配置一下开始使用吧.  Daemon Sync的客户端使用  下载Daemon Sync软件(安卓在google play,ios在app store) 保证和服务器在同一个局域网,注意要ipv4的,ipv6不支持. 开始使用吧.  Trouble Shoot  运行sudo dpkg -i daemonsync*.deb遇到:could not determine current runlevel提示:  suod export RUNLEVEL=1 //设置runlevel变量,解决提示:could not determine current runlevel的问题 sudo -E dpkg -i daemonsync*.deb //-E表示传递用户变量给root,dpkg -i安装软件  浏览器打不开配置页面或者加载慢:  /etc/init.d/daemonsync status //查看服务是否在运行,没运行就start起来 用服务器的本机浏览器打开配置页面,不要用手机或者平板端浏览器.\n","id":7,"section":"posts","summary":"Deamon Sync使用教程-同步相片和文件到本地 Daemon Sync介绍 Daemon Sync能够将手机中的相片或者其他应用同步到本地服务器上.它跨平台的,服务端可以安装","tags":null,"title":"Deamon Sync使用教程-同步相片和文件到本地","uri":"https://juzhencs.github.io/2018/04/2018-04-15/","year":"2018"},{"content":"ps2avrGB键盘刷QMK固件  先聊点题外话，鬼知道为什么我就进了客制化的大坑。\n如果是新人，请记得我的经验：客制化不省钱！客制化让键盘适应你，而不是你适应键盘！\nps2avrGB是韩国人开发的主控套件，国内也有很多人用这个做了定制化的开发，比如麦田外设的板子。（pcb上有mt字样）\nps2avrGB的官方刷板应用是BootmapperClient，github上luizribeiro为它做了qmk的适配。\nqmk顶顶大名，就不用多介绍了，基于chibiOS系统，支持模拟鼠标，可以一键进入刷机模式。总之功能特别强大！\n没错！你的键盘里跑着一个操作系统！！！还能代替鼠标！！！\n我买的是麦田的白色pcb的gh60板子，所以我只能以这个为例，记录下刷板子的过程。\n我的板子没上灯，所以关于灯光的设置都没有，如果你看得懂qmk文档可以自己加灯光配置。\n本文会默认读者已经有了一定的动手能力。毕竟你都搞客制化了，哪有纯菜鸟会玩这个？对吧。\n本文会默认读者能读懂英文教程，别怕，翻译软件站在你身后！\n 动手前请先看下全文，如果大多看不懂，请不要操作，键盘会变砖的！！！\n动手前请先看下全文，如果大多看不懂，请不要操作，键盘会变砖的！！！\n动手前请先看下全文，如果大多看不懂，请不要操作，键盘会变砖的！！！\n如果真的发生的悲剧，键盘变砖，你可以在github上给qmk提issue。\n但是我不会对此负责，也不保证能帮助你修复键盘\n今天是2018-01-26，如果时间过去太久这个教程可能已经失效了\n刷板子准备 在刷板子之前需要做好如下的准备：\n 1.把github上的luizriberiro的qmk项目clone到本地，并且配置好编译环境。 2.下载BootmapperClient，最新的版本最好。 3.找到进入键盘刷机模式(DFU模式)的方法。  qmk的开发环境我是在ubuntu环境下搭建的，qmk有详细教程，只要搭建好编译环境就可以，不用管烧录工具。\n我的bootmapperClient版本是v0.10.0\nps2avrGB进入刷机模式通常有两种：\n韩国的键盘是断开连接线，按住左ctrl或者U或者esc，然后再连接。\n一些国内客制化键盘是断开连接线，短接电路板上的两个接口，再连接。\n我的pcb是要短接电路板的，在电路板侧边缘有标p1的两个接口，我用镊子短接。\n一定注意不能用usb扩展口接键盘，电脑识别不出来的。\n进入刷机模式成功的标志就是连接电脑之后，键盘所有按键都没反应，变砖是部分按键没反应。\n生成刷机文件步骤 首先要修改qmk的代码以适配自己的键盘配列表。\n首先编辑config.h,适配键盘的配列。\n在#endif前添加如下内容：\n/* mouse settings*/ //定义模拟鼠标参数，单位毫秒 #define MOUSEKEY_DELAY 150 //鼠标连续移动延迟，过大笨拙，过小发飘 #define MOUSEKEY_INTERVAL 20 //鼠标刷新间隔 #define MOUSEKEY_MAX_SPEED 2 //鼠标最大速度 #define MOUSEKEY_TIME_TO_MAX 2 //鼠标到达最大速的时间 #define MOUSEKEY_WHEEL_MAX_SPEED 2 //鼠标滚轮最大速度 #define MOUSEKEY_WHEEL_TIME_TO_MAX 2 //鼠标滚轮到达最大速度的时间 再编辑ps2avrGB.h文件，适配键盘的配列。\n在#endif前添加如下内容：\n#define MY_KEYMAP( \\\r K31, K32, K33, K34, K35, K36, K37, K38, K39, K3A, K3B, K3C, K3D, K3F, \\\rK41, K42, K43, K44, K45, K46, K47, K48, K49, K4A, K4B, K4C, K4D, K4E, \\\rK51, K52, K53, K54, K55, K56, K57, K58, K59, K5A, K5B, K5C, K5E, \\\rK61, K63, K64, K65, K66, K67, K68, K69, K6A, K6B, K6C, K6E, \\\rK71, K72, K73, K78, K7A, K7B, K7D, K7E \\\r){ \\\r{ KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO }, \\\r{ KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO }, \\\r{ KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO }, \\\r{ K31, K32, K33, K34, K35, K36, K37, K38, K39, K3A, K3B, K3C, K3D, KC_NO, K3F }, \\\r{ K41, K42, K43, K44, K45, K46, K47, K48, K49, K4A, K4B, K4C, K4D, K4E, KC_NO }, \\\r{ K51, K52, K53, K54, K55, K56, K57, K58, K59, K5A, K5B, K5C, KC_NO, K5E, KC_NO }, \\\r{ K61, KC_NO, K63, K64, K65, K66, K67, K68, K69, K6A, K6B, K6C, KC_NO, K6E, KC_NO }, \\\r{ K71, K72, K73, KC_NO, KC_NO, KC_NO, KC_NO, K78, KC_NO, K7A, K7B, KC_NO, K7D, K7E, KC_NO } \\\r}\r配置的方法其实挺简单的。格式如下：\n#define MY_KEYMAP( \\\r K11, K12, K13, \\\rK21, K23 \\\r){ \\\r{ KC_11, KC_12, KC_13 }, \\\r{ KC_21, KC_NO, KC_23 } \\\r}\r上面的矩阵是我们的键盘轴排列方式，下面的矩阵是这些轴焊接在了哪里。\n比如我们设置了一个2x3的键盘矩阵，在上面焊了五个轴，排列如第一个矩阵。\n在第二个矩阵一一对应的，配置轴焊接的位置，没有焊轴的位置用NO占位。\n以上是我的怕pcb的布局，每个人习惯不同，布局都不同，可能需要微调。\n建立/root/qmk/qmk_firmware/keyboards/ps2avrGB/keymaps/mykeymap文件夹，最后的mykeymap可以任意改名。\n进入新建的文件夹，建立keymap.c文件。内容如下：\n#include \u0026#34;ps2avrGB.h\u0026#34;\r#include \u0026#34;action_layer.h\u0026#34;\r#include \u0026#34;rgblight.h\u0026#34;\r\rconst uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {\r[0] = MY_KEYMAP(\rKC_ESC, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_MINS, KC_EQL, KC_BSPC,\rKC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_LBRC, KC_RBRC, KC_BSLS,\rKC_LCTL, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_ENT,\rKC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_FN0,\rKC_FN1, KC_RGUI, KC_LALT, KC_SPC, KC_FN2, KC_APP, KC_CAPS, KC_INS\r),\r[1] = MY_KEYMAP(\rKC_GRV, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, KC_DEL,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_PGUP, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_HOME, KC_PGDN, KC_END, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS\r),\r[2] = MY_KEYMAP(\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_LEFT, KC_DOWN, KC_UP, KC_RGHT, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS\r),\r[3] = MY_KEYMAP(\rRESET, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_WH_U, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_MS_U, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_BTN2, KC_WH_D, KC_BTN1, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_MS_L, KC_MS_D, KC_MS_R, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS,\rKC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS, KC_TRNS\r),\r};\rconst uint16_t PROGMEM fn_actions[] = {\r[0] = ACTION_LAYER_MOMENTARY(1),\r[1] = ACTION_LAYER_MOMENTARY(2),\r[2] = ACTION_LAYER_MOMENTARY(3),\r};\r这里的键位设置是和ps2avrGB.h里的设置对应的。应该很容易看懂。\n默认键盘在第0层状态，按下FN0键进入第一层，按下FN1进入第二层，以此类推。\nKC_TRNS表示透明，比如字母K键。按下FN1和K键，从第0层进入第2层，KC_TRNS会透明映射到下面第0层，输出还是K。\nKC_MS_L就是鼠标模拟向左移动，具体的keycode可以参考qmk的keycode文档。\n第三层的左上角RESET键表示进入刷机(DFU)模式，有了这个键就不用每次都短接了。\n最后回到qmk_firmware,执行下面的命令：\nmake ps2avrGB\r大概会有一个这样的回显：\nMaking ps2avrGB with keymap default [OK]\rMaking ps2avrGB with keymap luizribeiro [OK]\rMaking ps2avrGB with keymap mykeyboard [OK]\r成功之后会生成ps2avrGB_mykeyboard.hex文件，就是我们的目标文件了。\n刷板子步骤 刷板子我是在windows平台上进行的，linux当然也可以，不过我没成功。\n通过按键或者短接，让键盘的板子进入刷机模式，连接电脑，打开bootmapperClient。\n右上角选option，左下角的utils里点firm up，弹出的窗口中选中ps2avrGB_mykeyboard.hex，刷机开始。\n没问题的话会弹出一个对话框，在跑马灯显示一堆二进制地址，不到10秒对话框消失，刷机完成。\n如果刷机成功，以后再刷的时候按reset键就可以进去刷机模式了，不用每次都短接。\n第一次配列肯定是会有问题的，用一段时间发现不方便再改，慢慢你的键盘就会进化出最适合你的配列。\n可能会遇到的问题 可能会遇到的最大的问题就是运气问题，我的板子变砖过，连上电脑不识别过。\n装驱动把其他设备驱动装坏过，编译debug一天没成果过。\n不过基本都是因为小问题，运气好的话是不会遇到的。\n运气不好的话，恭喜你！因为专家就是把能遇到的问题都遇到了一遍的人。\n","id":8,"section":"posts","summary":"ps2avrGB键盘刷QMK固件 先聊点题外话，鬼知道为什么我就进了客制化的大坑。 如果是新人，请记得我的经验：客制化不省钱！客制化让键盘适应你","tags":null,"title":"ps2avrGB键盘刷QMK固件","uri":"https://juzhencs.github.io/2018/02/2018-01-26/","year":"2018"},{"content":"如何写一篇科学论文  实际上这是在听了钟润阳老师的报告后觉得受益匪浅，然后按照钟老师的ppt重写的文章。这么长时间过去，有点记不清钟老师对传播报告的内容是否支持了。我十分感谢钟老师做这次报告，如果知道了钟老师不支持这种分享方式我会第一时间删除这篇博客。\n 一篇文章的结构  Titles 标题 Abstract 摘要 Introduction 介绍 Literature Review 文献评论 Case Study 案例分析 Conclusion 结论 Acknowledgement 确认 References 参考文献 Appendix 附录  如何选题 可以看一些文章，找一些问题，甚至之前工作的结果。然后进行头脑风暴，看哪里还可以完善。把内容写在一张纸上。找几个同学或者同事，对这些内容做一个评判。如果大家普遍认为这个脑洞开的好，就可以发文章。\n 一篇文章开三个脑洞就差不多了 如果是新观点，要想好名字，或者看看国内外同行怎么命名这个新观点 对于新观点要至少找到三个点，来证明它是新颖的  文章的主题分类 通常文章可以分为三类：\n 原始创新\n这类创新是最不容易出现的，比如开创一个领域的相对论。是科研狗的最高目标。 细节补充\n在大牛开创了领域之后，进行一些查缺补漏。比如有人提出孩子的身高和父母的遗传有关系，跟着可以发一篇文章。“我发现确实有关系，关系权重在10%到90%之间。”俗称跟班科研，是最容易水文章的方法。 新来源的创新\n这种创新实际上是垄断创新，比如探月计划可以出一大批文章，因为数据有了新的来源。如果自己有了新的实验来源而又不能垄断的话，就要学会隐藏数据来源了。 自己工作的跟进\n自己在做了一些工作之后，总有一些是还可以深入做，但是当时没时间或者精力做的。有条件之后把这些工作继续做下去，也是文章的来源。  Title and Abstract 标题和摘要  文章的标题要能够表达文章的所有的点\n一个好的标题能够一定程度上代替整篇文章，有一种成语的效果。坏的标题比如：基于xx方法的改进方法。好的标题比如：xx方法的yy改进。 摘要是对标题的扩充。\n摘要是对文章的引领，通常在标题定下之后摘要就该写出来了，而不是在最后的总结。  Introduction 介绍 实际文章都是套路，介绍的套路就是如下，可以用一段来写。下面每个点用一句或者两句话来写明白。\n 这篇文章要解决什么问题 这个问题为什么重要，或者说为什么这是个要解决的问题 对于这个问题，过去人们做了什么，以及剩下什么还没解决 必须要进一步做什么，本文的重点是什么(研究问题)，也可以加上本文不会涉及什么 本文旨在实现或者贡献什么(目的和目标)  大家要注意，写文章的根本目的是分享自己的想法，推动世界进步，所以一定要有贡献，否则文章是没有以意的。\n 如何实现这个目标(用非常简单的一句话表达，最好只使用简单的主谓宾句) 论文是如何组织的(不一定要有，推荐有) 引用名人名言(引用专家的话，其他权威的论文等等)  学术的圈子很小很深，审稿人很可能不懂文章所写的东西。这时可以引用一些公共权威来证明自己。比如在深度学习领域，引用hinton的文章证明自己的观点，审稿人就不敢轻易反对。每提到一个观点都要有参考文献对应。\nConclusion 总结  回顾这个问题为什么是新颖的，重要的 回顾一下自己的解决方法的好处，新颖性 总结结果的有效性，解释下原因 提出改进或扩展的方向\n要注意，不是提出未完成的工作，是再已完成的工作的基础上的扩展  ","id":9,"section":"posts","summary":"如何写一篇科学论文 实际上这是在听了钟润阳老师的报告后觉得受益匪浅，然后按照钟老师的ppt重写的文章。这么长时间过去，有点记不清钟老师对传播报","tags":null,"title":"如何写一篇科学论文","uri":"https://juzhencs.github.io/2018/02/2018-02-01/","year":"2018"},{"content":"给go get加进度条 go get的时候没有回显，实验室网又慢，看着一行命令很长时间不动挺按难受的，就想着能不能加个进度条。谷歌了一下，4年前就已经有大神实现了。\n让go get显示进度条(博客可能已经过期了)\n作为萌新，按着大神的方法也实现了这个功能，而且大神把原理说的非常清楚明白，感谢!!!\n大神思路很简单：\n 修改cmd.Run()执行的地方, 使其将输出定位到标准输出流上  重新记录一下我的操作过程，详细一些，方便和我一样的萌新们。\n我的版本是：go1.9.2\n编辑/usr/local/go/src/cmd/go/internal/get/vcs.go。\ncmd.Stdout = \u0026amp;buf cmd.Stderr = \u0026amp;buf //添加cmd.Stdout = os.Stdout //添加cmd.Stderr = os.Stderr 成\ncmd.Stdout = \u0026amp;buf cmd.Stderr = \u0026amp;buf cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr 然后跑一遍/usr/local/go/src/run.bash\n之后运行go get就有回显了\nCloning into \u0026#39;/root/go/src/github.com/go-redis/redis\u0026#39;... remote: Counting objects: 4026, done. remote: Compressing objects: 100% (18/18), done. Receiving objects: 69% (2784/4026), 1.14 MiB | 8.00 KiB/s ","id":10,"section":"posts","summary":"给go get加进度条 go get的时候没有回显，实验室网又慢，看着一行命令很长时间不动挺按难受的，就想着能不能加个进度条。谷歌了一下，4年前就已","tags":null,"title":"给go get加进度条","uri":"https://juzhencs.github.io/2018/01/2018-01-19/","year":"2018"}],"tags":[{"title":"VSCode","uri":"https://juzhencs.github.io/tags/vscode/"},{"title":"动态规划","uri":"https://juzhencs.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"工具推荐","uri":"https://juzhencs.github.io/tags/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"},{"title":"最长公共子序列","uri":"https://juzhencs.github.io/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"最长递增子序列","uri":"https://juzhencs.github.io/tags/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"}]}